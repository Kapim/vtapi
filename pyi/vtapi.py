# This file has been generated by Py++.

#include "boost/python.hpp"

#include "__array_1.pypp.hpp"

#include "boost/python/suite/indexing/vector_indexing_suite.hpp"

#include "boost/python/suite/indexing/map_indexing_suite.hpp"

#include "/home/chmelarp/Projects/VTApi/vtapi/include/vtapi_commons.h"

#include "/home/chmelarp/Projects/VTApi/vtapi/include/vtapi.h"

namespace bp = boost::python;

struct Commons_wrapper : Commons, bp::wrapper< Commons > {

    Commons_wrapper(::Commons const & orig )
    : Commons( boost::ref(orig) )
      , bp::wrapper< Commons >(){
        // copy constructor
    
    }

    Commons_wrapper(::Connector & other )
    : Commons( boost::ref(other) )
      , bp::wrapper< Commons >(){
        // constructor
    
    }

    Commons_wrapper(::String const & connStr, ::String const & logFilename="" )
    : Commons( connStr, logFilename )
      , bp::wrapper< Commons >(){
        // constructor
    
    }

    Commons_wrapper(::String const connStr, ::String const location, ::String const user, ::String const password, ::String const logFilename="" )
    : Commons( connStr, location, user, password, logFilename )
      , bp::wrapper< Commons >(){
        // constructor
    
    }

    Commons_wrapper(::gengetopt_args_info const & args_info, ::String const & logFilename="" )
    : Commons( boost::ref(args_info), logFilename )
      , bp::wrapper< Commons >(){
        // constructor
    
    }

    void registerTypes(  ){
        Commons::registerTypes(  );
    }

};

struct Connector_wrapper : Connector, bp::wrapper< Connector > {

    Connector_wrapper(::Connector const & orig )
    : Connector( boost::ref(orig) )
      , bp::wrapper< Connector >(){
        // copy constructor
    
    }

    Connector_wrapper(::String const & connectionInfo, ::Logger * logger=0l )
    : Connector( connectionInfo, boost::python::ptr(logger) )
      , bp::wrapper< Connector >(){
        // constructor
    
    }

    static ::PGconn * get_conn(Connector const & inst ){
        return inst.conn;
    }
    
    static void set_conn( Connector & inst, ::PGconn * new_value ){ 
        inst.conn = new_value;
    }

    static ::Logger * get_logger(Connector const & inst ){
        return inst.logger;
    }
    
    static void set_logger( Connector & inst, ::Logger * new_value ){ 
        inst.logger = new_value;
    }

};

struct KeyValues_wrapper : KeyValues, bp::wrapper< KeyValues > {

    KeyValues_wrapper(::Commons const & orig )
    : KeyValues( boost::ref(orig) )
      , bp::wrapper< KeyValues >(){
        // constructor
    
    }

    KeyValues_wrapper(::KeyValues const & orig )
    : KeyValues( boost::ref(orig) )
      , bp::wrapper< KeyValues >(){
        // copy constructor
    
    }

    static ::Insert * get_insert(KeyValues const & inst ){
        return inst.insert;
    }
    
    static void set_insert( KeyValues & inst, ::Insert * new_value ){ 
        inst.insert = new_value;
    }

    static ::Select * get_select(KeyValues const & inst ){
        return inst.select;
    }
    
    static void set_select( KeyValues & inst, ::Select * new_value ){ 
        inst.select = new_value;
    }

    void registerTypes(  ){
        Commons::registerTypes(  );
    }

};

struct Dataset_wrapper : Dataset, bp::wrapper< Dataset > {

    Dataset_wrapper(Dataset const & arg )
    : Dataset( arg )
      , bp::wrapper< Dataset >(){
        // copy constructor
        
    }

    Dataset_wrapper(::KeyValues const & orig, ::String const & name="" )
    : Dataset( boost::ref(orig), name )
      , bp::wrapper< Dataset >(){
        // constructor
    
    }

    void registerTypes(  ){
        Commons::registerTypes(  );
    }

};

struct Interval_wrapper : Interval, bp::wrapper< Interval > {

    Interval_wrapper(Interval const & arg )
    : Interval( arg )
      , bp::wrapper< Interval >(){
        // copy constructor
        
    }

    Interval_wrapper(::KeyValues const & orig, ::String const & selection="intervals" )
    : Interval( boost::ref(orig), selection )
      , bp::wrapper< Interval >(){
        // constructor
    
    }

    void registerTypes(  ){
        Commons::registerTypes(  );
    }

};

struct Image_wrapper : Image, bp::wrapper< Image > {

    Image_wrapper(Image const & arg )
    : Image( arg )
      , bp::wrapper< Image >(){
        // copy constructor
        
    }

    Image_wrapper(::KeyValues const & orig, ::String const & selection="intervals" )
    : Image( boost::ref(orig), selection )
      , bp::wrapper< Image >(){
        // constructor
    
    }

    void registerTypes(  ){
        Commons::registerTypes(  );
    }

};

struct Query_wrapper : Query, bp::wrapper< Query > {

    Query_wrapper(Query const & arg )
    : Query( arg )
      , bp::wrapper< Query >(){
        // copy constructor
        
    }

    Query_wrapper(::Commons const & commons, ::String const & query="", ::PGparam * param=0l )
    : Query( boost::ref(commons), query, boost::python::ptr(param) )
      , bp::wrapper< Query >(){
        // constructor
    
    }

    virtual ::String getQuery(  ) {
        if( bp::override func_getQuery = this->get_override( "getQuery" ) )
            return func_getQuery(  );
        else
            return this->Query::getQuery(  );
    }
    
    
    ::String default_getQuery(  ) {
        return Query::getQuery( );
    }

    static ::PGparam * get_param(Query const & inst ){
        return inst.param;
    }
    
    static void set_param( Query & inst, ::PGparam * new_value ){ 
        inst.param = new_value;
    }

    static ::PGresult * get_res(Query const & inst ){
        return inst.res;
    }
    
    static void set_res( Query & inst, ::PGresult * new_value ){ 
        inst.res = new_value;
    }

    void registerTypes(  ){
        Commons::registerTypes(  );
    }

};

struct Insert_wrapper : Insert, bp::wrapper< Insert > {

    Insert_wrapper(Insert const & arg )
    : Insert( arg )
      , bp::wrapper< Insert >(){
        // copy constructor
        
    }

    Insert_wrapper(::Commons const & commons, ::String const & insertString="", ::PGparam * param=0l )
    : Insert( boost::ref(commons), insertString, boost::python::ptr(param) )
      , bp::wrapper< Insert >(){
        // constructor
    
    }

    virtual ::String getQuery(  ) {
        if( bp::override func_getQuery = this->get_override( "getQuery" ) )
            return func_getQuery(  );
        else
            return this->Insert::getQuery(  );
    }
    
    
    ::String default_getQuery(  ) {
        return Insert::getQuery( );
    }

    void registerTypes(  ){
        Commons::registerTypes(  );
    }

};

struct Method_wrapper : Method, bp::wrapper< Method > {

    Method_wrapper(Method const & arg )
    : Method( arg )
      , bp::wrapper< Method >(){
        // copy constructor
        
    }

    Method_wrapper(::KeyValues const & orig, ::String const & name="" )
    : Method( boost::ref(orig), name )
      , bp::wrapper< Method >(){
        // constructor
    
    }

    void registerTypes(  ){
        Commons::registerTypes(  );
    }

};

struct PGarray_wrapper : PGarray, bp::wrapper< PGarray > {

    PGarray_wrapper(PGarray const & arg )
    : PGarray( arg )
      , bp::wrapper< PGarray >(){
        // copy constructor
        
    }

    PGarray_wrapper()
    : PGarray()
      , bp::wrapper< PGarray >(){
        // null constructor
        
    }

    static pyplusplus::containers::static_sized::array_1_t< int, 6>
    pyplusplus_dims_wrapper( ::PGarray & inst ){
        return pyplusplus::containers::static_sized::array_1_t< int, 6>( inst.dims );
    }

    static pyplusplus::containers::static_sized::array_1_t< int, 6>
    pyplusplus_lbound_wrapper( ::PGarray & inst ){
        return pyplusplus::containers::static_sized::array_1_t< int, 6>( inst.lbound );
    }

    static ::PGparam * get_param(PGarray const & inst ){
        return inst.param;
    }
    
    static void set_param( PGarray & inst, ::PGparam * new_value ){ 
        inst.param = new_value;
    }

    static ::PGresult * get_res(PGarray const & inst ){
        return inst.res;
    }
    
    static void set_res( PGarray & inst, ::PGresult * new_value ){ 
        inst.res = new_value;
    }

};

struct PGinet_wrapper : PGinet, bp::wrapper< PGinet > {

    PGinet_wrapper(PGinet const & arg )
    : PGinet( arg )
      , bp::wrapper< PGinet >(){
        // copy constructor
        
    }

    PGinet_wrapper()
    : PGinet()
      , bp::wrapper< PGinet >(){
        // null constructor
        
    }

    static pyplusplus::containers::static_sized::array_1_t< char, 128>
    pyplusplus_sa_buf_wrapper( ::PGinet & inst ){
        return pyplusplus::containers::static_sized::array_1_t< char, 128>( inst.sa_buf );
    }

};

struct PGlseg_wrapper : PGlseg, bp::wrapper< PGlseg > {

    PGlseg_wrapper(PGlseg const & arg )
    : PGlseg( arg )
      , bp::wrapper< PGlseg >(){
        // copy constructor
        
    }

    PGlseg_wrapper()
    : PGlseg()
      , bp::wrapper< PGlseg >(){
        // null constructor
        
    }

    static pyplusplus::containers::static_sized::array_1_t< ::PGpoint, 2>
    pyplusplus_pts_wrapper( ::PGlseg & inst ){
        return pyplusplus::containers::static_sized::array_1_t< ::PGpoint, 2>( inst.pts );
    }

};

struct PGpath_wrapper : PGpath, bp::wrapper< PGpath > {

    PGpath_wrapper(PGpath const & arg )
    : PGpath( arg )
      , bp::wrapper< PGpath >(){
        // copy constructor
        
    }

    PGpath_wrapper()
    : PGpath()
      , bp::wrapper< PGpath >(){
        // null constructor
        
    }

    static ::PGpoint * get_pts(PGpath const & inst ){
        return inst.pts;
    }
    
    static void set_pts( PGpath & inst, ::PGpoint * new_value ){ 
        inst.pts = new_value;
    }

};

struct PGpolygon_wrapper : PGpolygon, bp::wrapper< PGpolygon > {

    PGpolygon_wrapper(PGpolygon const & arg )
    : PGpolygon( arg )
      , bp::wrapper< PGpolygon >(){
        // copy constructor
        
    }

    PGpolygon_wrapper()
    : PGpolygon()
      , bp::wrapper< PGpolygon >(){
        // null constructor
        
    }

    static ::PGpoint * get_pts(PGpolygon const & inst ){
        return inst.pts;
    }
    
    static void set_pts( PGpolygon & inst, ::PGpoint * new_value ){ 
        inst.pts = new_value;
    }

};

struct PGrecordAttDesc_wrapper : PGrecordAttDesc, bp::wrapper< PGrecordAttDesc > {

    PGrecordAttDesc_wrapper(PGrecordAttDesc const & arg )
    : PGrecordAttDesc( arg )
      , bp::wrapper< PGrecordAttDesc >(){
        // copy constructor
        
    }

    PGrecordAttDesc_wrapper()
    : PGrecordAttDesc()
      , bp::wrapper< PGrecordAttDesc >(){
        // null constructor
        
    }

    static pyplusplus::containers::static_sized::array_1_t< char, 65>
    pyplusplus_attname_wrapper( ::PGrecordAttDesc & inst ){
        return pyplusplus::containers::static_sized::array_1_t< char, 65>( inst.attname );
    }

};

struct PGtime_wrapper : PGtime, bp::wrapper< PGtime > {

    PGtime_wrapper(PGtime const & arg )
    : PGtime( arg )
      , bp::wrapper< PGtime >(){
        // copy constructor
        
    }

    PGtime_wrapper()
    : PGtime()
      , bp::wrapper< PGtime >(){
        // null constructor
        
    }

    static pyplusplus::containers::static_sized::array_1_t< char, 16>
    pyplusplus_tzabbr_wrapper( ::PGtime & inst ){
        return pyplusplus::containers::static_sized::array_1_t< char, 16>( inst.tzabbr );
    }

};

struct PGtypeFormatInfo_wrapper : PGtypeFormatInfo, bp::wrapper< PGtypeFormatInfo > {

    PGtypeFormatInfo_wrapper(PGtypeFormatInfo const & arg )
    : PGtypeFormatInfo( arg )
      , bp::wrapper< PGtypeFormatInfo >(){
        // copy constructor
        
    }

    PGtypeFormatInfo_wrapper()
    : PGtypeFormatInfo()
      , bp::wrapper< PGtypeFormatInfo >(){
        // null constructor
        
    }

    static pyplusplus::containers::static_sized::array_1_t< char, 48>
    pyplusplus_datestyle_wrapper( ::PGtypeFormatInfo & inst ){
        return pyplusplus::containers::static_sized::array_1_t< char, 48>( inst.datestyle );
    }

};

struct Process_wrapper : Process, bp::wrapper< Process > {

    Process_wrapper(Process const & arg )
    : Process( arg )
      , bp::wrapper< Process >(){
        // copy constructor
        
    }

    Process_wrapper(::KeyValues const & orig, ::String const & name="" )
    : Process( boost::ref(orig), name )
      , bp::wrapper< Process >(){
        // constructor
    
    }

    void registerTypes(  ){
        Commons::registerTypes(  );
    }

};

struct Select_wrapper : Select, bp::wrapper< Select > {

    Select_wrapper(Select const & arg )
    : Select( arg )
      , bp::wrapper< Select >(){
        // copy constructor
        
    }

    Select_wrapper(::Commons const & commons, ::String const & queryString="", ::PGparam * param=0l )
    : Select( boost::ref(commons), queryString, boost::python::ptr(param) )
      , bp::wrapper< Select >(){
        // constructor
    
    }

    virtual ::String getQuery(  ) {
        if( bp::override func_getQuery = this->get_override( "getQuery" ) )
            return func_getQuery(  );
        else
            return this->Select::getQuery(  );
    }
    
    
    ::String default_getQuery(  ) {
        return Select::getQuery( );
    }

    void registerTypes(  ){
        Commons::registerTypes(  );
    }

};

struct Sequence_wrapper : Sequence, bp::wrapper< Sequence > {

    Sequence_wrapper(Sequence const & arg )
    : Sequence( arg )
      , bp::wrapper< Sequence >(){
        // copy constructor
        
    }

    Sequence_wrapper(::KeyValues const & orig, ::String const & name="" )
    : Sequence( boost::ref(orig), name )
      , bp::wrapper< Sequence >(){
        // constructor
    
    }

    bool openImage( ::String const & name ){
        return Sequence::openImage( name );
    }

    bool openVideo( ::String const & name ){
        return Sequence::openVideo( name );
    }

    void registerTypes(  ){
        Commons::registerTypes(  );
    }

};

struct VTApi_wrapper : VTApi, bp::wrapper< VTApi > {

    VTApi_wrapper(int argc, char * * argv )
    : VTApi( argc, argv )
      , bp::wrapper< VTApi >(){
        // constructor
    
    }

    VTApi_wrapper(::String const & configFile )
    : VTApi( configFile )
      , bp::wrapper< VTApi >(){
        // constructor
    
    }

    VTApi_wrapper(::String const & connStr, ::String const & location, ::String const & user, ::String const & password )
    : VTApi( connStr, location, user, password )
      , bp::wrapper< VTApi >(){
        // constructor
    
    }

    VTApi_wrapper(::Commons const & orig )
    : VTApi( boost::ref(orig) )
      , bp::wrapper< VTApi >(){
        // constructor
    
    }

    VTApi_wrapper(::VTApi const & orig )
    : VTApi( boost::ref(orig) )
      , bp::wrapper< VTApi >(){
        // copy constructor
    
    }

    static ::Commons * get_commons(VTApi const & inst ){
        return inst.commons;
    }
    
    static void set_commons( VTApi & inst, ::Commons * new_value ){ 
        inst.commons = new_value;
    }

};

struct gengetopt_args_info_wrapper : gengetopt_args_info, bp::wrapper< gengetopt_args_info > {

    gengetopt_args_info_wrapper(gengetopt_args_info const & arg )
    : gengetopt_args_info( arg )
      , bp::wrapper< gengetopt_args_info >(){
        // copy constructor
        
    }

    gengetopt_args_info_wrapper()
    : gengetopt_args_info()
      , bp::wrapper< gengetopt_args_info >(){
        // null constructor
        
    }

    static char * * get_inputs(gengetopt_args_info const & inst ){
        return inst.inputs;
    }
    
    static void set_inputs( gengetopt_args_info & inst, char * * new_value ){ 
        inst.inputs = new_value;
    }

};

struct pg_typeargs_wrapper : pg_typeargs, bp::wrapper< pg_typeargs > {

    pg_typeargs_wrapper(pg_typeargs const & arg )
    : pg_typeargs( arg )
      , bp::wrapper< pg_typeargs >(){
        // copy constructor
        
    }

    pg_typeargs_wrapper()
    : pg_typeargs()
      , bp::wrapper< pg_typeargs >(){
        // null constructor
        
    }

    static pyplusplus::containers::static_sized::array_1_t< ::__va_list_tag, 1>
    pyplusplus_ap_wrapper( ::pg_typeargs & inst ){
        return pyplusplus::containers::static_sized::array_1_t< ::__va_list_tag, 1>( inst.ap );
    }

    static ::PGtypeFormatInfo const * get_fmtinfo(pg_typeargs const & inst ){
        return inst.fmtinfo;
    }
    
    static void set_fmtinfo( pg_typeargs & inst, ::PGtypeFormatInfo const * new_value ){ 
        inst.fmtinfo = new_value;
    }

    static ::PGtypeHandler * get_typhandler(pg_typeargs const & inst ){
        return inst.typhandler;
    }
    
    static void set_typhandler( pg_typeargs & inst, ::PGtypeHandler * new_value ){ 
        inst.typhandler = new_value;
    }

};

struct pg_typhandler_wrapper : pg_typhandler, bp::wrapper< pg_typhandler > {

    pg_typhandler_wrapper(pg_typhandler const & arg )
    : pg_typhandler( arg )
      , bp::wrapper< pg_typhandler >(){
        // copy constructor
        
    }

    pg_typhandler_wrapper()
    : pg_typhandler()
      , bp::wrapper< pg_typhandler >(){
        // null constructor
        
    }

    static ::PGrecordAttDesc * get_attDescs(pg_typhandler const & inst ){
        return inst.attDescs;
    }
    
    static void set_attDescs( pg_typhandler & inst, ::PGrecordAttDesc * new_value ){ 
        inst.attDescs = new_value;
    }

    static pyplusplus::containers::static_sized::array_1_t< ::PGrecordAttDesc, 16>
    pyplusplus_attDescsBuf_wrapper( ::pg_typhandler & inst ){
        return pyplusplus::containers::static_sized::array_1_t< ::PGrecordAttDesc, 16>( inst.attDescsBuf );
    }

    static pyplusplus::containers::static_sized::array_1_t< char, 65>
    pyplusplus_typname_wrapper( ::pg_typhandler & inst ){
        return pyplusplus::containers::static_sized::array_1_t< char, 65>( inst.typname );
    }

    static pyplusplus::containers::static_sized::array_1_t< char, 65>
    pyplusplus_typschema_wrapper( ::pg_typhandler & inst ){
        return pyplusplus::containers::static_sized::array_1_t< char, 65>( inst.typschema );
    }

};

BOOST_PYTHON_MODULE(vtapi){
    bp::class_< std::vector< int > >("vector_less__int__greater_")    
        .def( bp::vector_indexing_suite< ::std::vector< int >, true >() );

    { //::std::vector< TKey >
        typedef bp::class_< std::vector< TKey > > vector_less__TKey__greater__exposer_t;
        vector_less__TKey__greater__exposer_t vector_less__TKey__greater__exposer = vector_less__TKey__greater__exposer_t( "vector_less__TKey__greater_" );
        bp::scope vector_less__TKey__greater__scope( vector_less__TKey__greater__exposer );
        //WARNING: the next line of code will not compile, because "::TKey" does not have operator== !
        vector_less__TKey__greater__exposer.def( bp::vector_indexing_suite< ::std::vector< TKey > >() );
    }

    bp::class_< std::map< std::string, std::string > >("map_less__std_scope_string_comma__std_scope_string__greater_")    
        .def( bp::map_indexing_suite< ::std::map< std::string, std::string >, true >() );

    bp::scope().attr("PQT_SUBCLASS") = (int)PQT_SUBCLASS;
    bp::scope().attr("PQT_COMPOSITE") = (int)PQT_COMPOSITE;
    bp::scope().attr("PQT_USERDEFINED") = (int)PQT_USERDEFINED;

    { //::Commons
        typedef bp::class_< Commons_wrapper > Commons_exposer_t;
        Commons_exposer_t Commons_exposer = Commons_exposer_t( "Commons", bp::init< Commons const & >(( bp::arg("orig") )) );
        bp::scope Commons_scope( Commons_exposer );
        Commons_exposer.def( bp::init< Connector & >(( bp::arg("other") )) );
        bp::implicitly_convertible< Connector &, Commons >();
        Commons_exposer.def( bp::init< String const &, bp::optional< String const & > >(( bp::arg("connStr"), bp::arg("logFilename")="" )) );
        Commons_exposer.def( bp::init< std::string, std::string, std::string, std::string, bp::optional< std::string > >(( bp::arg("connStr"), bp::arg("location"), bp::arg("user"), bp::arg("password"), bp::arg("logFilename")="" )) );
        Commons_exposer.def( bp::init< gengetopt_args_info const &, bp::optional< String const & > >(( bp::arg("args_info"), bp::arg("logFilename")="" )) );
        { //::Commons::beDoomed
        
            typedef void ( ::Commons::*beDoomed_function_type )(  ) ;
            
            Commons_exposer.def( 
                "beDoomed"
                , beDoomed_function_type( &::Commons::beDoomed ) );
        
        }
        { //::Commons::error
        
            typedef void ( ::Commons::*error_function_type )( int,::String const & ) ;
            
            Commons_exposer.def( 
                "error"
                , error_function_type( &::Commons::error )
                , ( bp::arg("errnum"), bp::arg("logline") ) );
        
        }
        { //::Commons::error
        
            typedef void ( ::Commons::*error_function_type )( ::String const & ) ;
            
            Commons_exposer.def( 
                "error"
                , error_function_type( &::Commons::error )
                , ( bp::arg("message") ) );
        
        }
        { //::Commons::getConnector
        
            typedef ::Connector * ( ::Commons::*getConnector_function_type )(  ) ;
            
            Commons_exposer.def( 
                "getConnector"
                , getConnector_function_type( &::Commons::getConnector )
                    /* undefined call policies */ );
        
        }
        { //::Commons::getDataLocation
        
            typedef ::String ( ::Commons::*getDataLocation_function_type )(  ) ;
            
            Commons_exposer.def( 
                "getDataLocation"
                , getDataLocation_function_type( &::Commons::getDataLocation ) );
        
        }
        { //::Commons::getDataset
        
            typedef ::String ( ::Commons::*getDataset_function_type )(  ) ;
            
            Commons_exposer.def( 
                "getDataset"
                , getDataset_function_type( &::Commons::getDataset ) );
        
        }
        { //::Commons::getLogger
        
            typedef ::Logger * ( ::Commons::*getLogger_function_type )(  ) ;
            
            Commons_exposer.def( 
                "getLogger"
                , getLogger_function_type( &::Commons::getLogger )
                    /* undefined call policies */ );
        
        }
        { //::Commons::getSelection
        
            typedef ::String ( ::Commons::*getSelection_function_type )(  ) ;
            
            Commons_exposer.def( 
                "getSelection"
                , getSelection_function_type( &::Commons::getSelection ) );
        
        }
        { //::Commons::getSequence
        
            typedef ::String ( ::Commons::*getSequence_function_type )(  ) ;
            
            Commons_exposer.def( 
                "getSequence"
                , getSequence_function_type( &::Commons::getSequence ) );
        
        }
        { //::Commons::printRes
        
            typedef void ( ::Commons::*printRes_function_type )( ::PGresult *,::String const & ) ;
            
            Commons_exposer.def( 
                "printRes"
                , printRes_function_type( &::Commons::printRes )
                , ( bp::arg("res"), bp::arg("format") ) );
        
        }
        { //::Commons::printRes
        
            typedef void ( ::Commons::*printRes_function_type )( ::PGresult *,int,::String const & ) ;
            
            Commons_exposer.def( 
                "printRes"
                , printRes_function_type( &::Commons::printRes )
                , ( bp::arg("res"), bp::arg("pTuple")=(int)(-0x00000000000000001), bp::arg("format")="" ) );
        
        }
        { //::Commons::read
        
            typedef void ( ::Commons::*read_function_type )( ::String const & ) ;
            
            Commons_exposer.def( 
                "read"
                , read_function_type( &::Commons::read )
                , ( bp::arg("format")="" ) );
        
        }
        { //::Commons::registerTypes
        
            typedef void ( Commons_wrapper::*registerTypes_function_type )(  ) ;
            
            Commons_exposer.def( 
                "registerTypes"
                , registerTypes_function_type( &Commons_wrapper::registerTypes ) );
        
        }
        { //::Commons::toOid
        
            typedef int ( ::Commons::*toOid_function_type )( ::String ) ;
            
            Commons_exposer.def( 
                "toOid"
                , toOid_function_type( &::Commons::toOid )
                , ( bp::arg("typname") ) );
        
        }
        { //::Commons::toTypname
        
            typedef ::String ( ::Commons::*toTypname_function_type )( int ) ;
            
            Commons_exposer.def( 
                "toTypname"
                , toTypname_function_type( &::Commons::toTypname )
                , ( bp::arg("oid") ) );
        
        }
        { //::Commons::warning
        
            typedef void ( ::Commons::*warning_function_type )( int,::String const & ) ;
            
            Commons_exposer.def( 
                "warning"
                , warning_function_type( &::Commons::warning )
                , ( bp::arg("errnum"), bp::arg("logline") ) );
        
        }
        { //::Commons::warning
        
            typedef void ( ::Commons::*warning_function_type )( ::String const & ) ;
            
            Commons_exposer.def( 
                "warning"
                , warning_function_type( &::Commons::warning )
                , ( bp::arg("message") ) );
        
        }
    }

    { //::Logger
        typedef bp::class_< Logger, boost::noncopyable > Logger_exposer_t;
        Logger_exposer_t Logger_exposer = Logger_exposer_t( "Logger", bp::init< bp::optional< String const & > >(( bp::arg("filename")="" )) );
        bp::scope Logger_scope( Logger_exposer );
        bp::implicitly_convertible< String const &, Logger >();
        { //::Logger::debug
        
            typedef void ( ::Logger::*debug_function_type )( ::String const & ) ;
            
            Logger_exposer.def( 
                "debug"
                , debug_function_type( &::Logger::debug )
                , ( bp::arg("message") ) );
        
        }
        { //::Logger::log
        
            typedef void ( ::Logger::*log_function_type )( ::String const & ) ;
            
            Logger_exposer.def( 
                "log"
                , log_function_type( &::Logger::log )
                , ( bp::arg("message") ) );
        
        }
        { //::Logger::timestamp
        
            typedef ::String ( ::Logger::*timestamp_function_type )(  ) ;
            
            Logger_exposer.def( 
                "timestamp"
                , timestamp_function_type( &::Logger::timestamp ) );
        
        }
        { //::Logger::write
        
            typedef void ( ::Logger::*write_function_type )( ::String const & ) ;
            
            Logger_exposer.def( 
                "write"
                , write_function_type( &::Logger::write )
                , ( bp::arg("message") ) );
        
        }
    }

    bp::class_< Connector_wrapper >( "Connector", bp::init< Connector const & >(( bp::arg("orig") )) )    
        .def( bp::init< String const &, bp::optional< Logger * > >(( bp::arg("connectionInfo"), bp::arg("logger")=0l )) )    
        .def( 
            "connected"
            , (bool ( ::Connector::* )(  ) )( &::Connector::connected ) )    
        .def( 
            "getConn"
            , (::PGconn * ( ::Connector::* )(  ) )( &::Connector::getConn )
                /* undefined call policies */ )    
        .def( 
            "getLogger"
            , (::Logger * ( ::Connector::* )(  ) )( &::Connector::getLogger )
                /* undefined call policies */ )    
        .def( 
            "reconnect"
            , (bool ( ::Connector::* )( ::String const & ) )( &::Connector::reconnect )
            , ( bp::arg("connectionInfo") ) )    
        .add_property( "conn"
                    , bp::make_function( (::PGconn * (*)( ::Connector const & ))(&Connector_wrapper::get_conn), bp::return_internal_reference< >() )
                    , bp::make_function( (void (*)( ::Connector &,::PGconn * ))(&Connector_wrapper::set_conn), bp::with_custodian_and_ward_postcall< 1, 2 >() ) )    
        .def_readwrite( "conninfo", &Connector::conninfo )    
        .add_property( "logger"
                    , bp::make_function( (::Logger * (*)( ::Connector const & ))(&Connector_wrapper::get_logger), bp::return_internal_reference< >() )
                    , bp::make_function( (void (*)( ::Connector &,::Logger * ))(&Connector_wrapper::set_logger), bp::with_custodian_and_ward_postcall< 1, 2 >() ) );

    { //::KeyValues
        typedef bp::class_< KeyValues_wrapper, bp::bases< Commons > > KeyValues_exposer_t;
        KeyValues_exposer_t KeyValues_exposer = KeyValues_exposer_t( "KeyValues", bp::init< Commons const & >(( bp::arg("orig") )) );
        bp::scope KeyValues_scope( KeyValues_exposer );
        bp::implicitly_convertible< Commons const &, KeyValues >();
        KeyValues_exposer.def( bp::init< KeyValues const & >(( bp::arg("orig") )) );
        { //::KeyValues::addFloat
        
            typedef bool ( ::KeyValues::*addFloat_function_type )( ::String,::String ) ;
            
            KeyValues_exposer.def( 
                "addFloat"
                , addFloat_function_type( &::KeyValues::addFloat )
                , ( bp::arg("key"), bp::arg("value") ) );
        
        }
        { //::KeyValues::addFloat
        
            typedef bool ( ::KeyValues::*addFloat_function_type )( ::String,float ) ;
            
            KeyValues_exposer.def( 
                "addFloat"
                , addFloat_function_type( &::KeyValues::addFloat )
                , ( bp::arg("key"), bp::arg("value") ) );
        
        }
        { //::KeyValues::addFloatA
        
            typedef bool ( ::KeyValues::*addFloatA_function_type )( ::String,float *,int ) ;
            
            KeyValues_exposer.def( 
                "addFloatA"
                , addFloatA_function_type( &::KeyValues::addFloatA )
                , ( bp::arg("key"), bp::arg("value"), bp::arg("size") ) );
        
        }
        { //::KeyValues::addInt
        
            typedef bool ( ::KeyValues::*addInt_function_type )( ::String,::String ) ;
            
            KeyValues_exposer.def( 
                "addInt"
                , addInt_function_type( &::KeyValues::addInt )
                , ( bp::arg("key"), bp::arg("value") ) );
        
        }
        { //::KeyValues::addInt
        
            typedef bool ( ::KeyValues::*addInt_function_type )( ::String,int ) ;
            
            KeyValues_exposer.def( 
                "addInt"
                , addInt_function_type( &::KeyValues::addInt )
                , ( bp::arg("key"), bp::arg("value") ) );
        
        }
        { //::KeyValues::addIntA
        
            typedef bool ( ::KeyValues::*addIntA_function_type )( ::String,int *,int ) ;
            
            KeyValues_exposer.def( 
                "addIntA"
                , addIntA_function_type( &::KeyValues::addIntA )
                , ( bp::arg("key"), bp::arg("value"), bp::arg("size") ) );
        
        }
        { //::KeyValues::addString
        
            typedef bool ( ::KeyValues::*addString_function_type )( ::String,::String ) ;
            
            KeyValues_exposer.def( 
                "addString"
                , addString_function_type( &::KeyValues::addString )
                , ( bp::arg("key"), bp::arg("value") ) );
        
        }
        { //::KeyValues::getFloat
        
            typedef float ( ::KeyValues::*getFloat_function_type )( ::String ) ;
            
            KeyValues_exposer.def( 
                "getFloat"
                , getFloat_function_type( &::KeyValues::getFloat )
                , ( bp::arg("key") ) );
        
        }
        { //::KeyValues::getFloat
        
            typedef float ( ::KeyValues::*getFloat_function_type )( int ) ;
            
            KeyValues_exposer.def( 
                "getFloat"
                , getFloat_function_type( &::KeyValues::getFloat )
                , ( bp::arg("pos") ) );
        
        }
        { //::KeyValues::getFloatA
        
            typedef float * ( ::KeyValues::*getFloatA_function_type )( ::String,int & ) ;
            
            KeyValues_exposer.def( 
                "getFloatA"
                , getFloatA_function_type( &::KeyValues::getFloatA )
                , ( bp::arg("key"), bp::arg("size") )
                    /* undefined call policies */ );
        
        }
        { //::KeyValues::getFloatA
        
            typedef float * ( ::KeyValues::*getFloatA_function_type )( int,int & ) ;
            
            KeyValues_exposer.def( 
                "getFloatA"
                , getFloatA_function_type( &::KeyValues::getFloatA )
                , ( bp::arg("pos"), bp::arg("size") )
                    /* undefined call policies */ );
        
        }
        { //::KeyValues::getInt
        
            typedef int ( ::KeyValues::*getInt_function_type )( ::String ) ;
            
            KeyValues_exposer.def( 
                "getInt"
                , getInt_function_type( &::KeyValues::getInt )
                , ( bp::arg("key") ) );
        
        }
        { //::KeyValues::getInt
        
            typedef int ( ::KeyValues::*getInt_function_type )( int ) ;
            
            KeyValues_exposer.def( 
                "getInt"
                , getInt_function_type( &::KeyValues::getInt )
                , ( bp::arg("pos") ) );
        
        }
        { //::KeyValues::getIntA
        
            typedef int * ( ::KeyValues::*getIntA_function_type )( ::String,int & ) ;
            
            KeyValues_exposer.def( 
                "getIntA"
                , getIntA_function_type( &::KeyValues::getIntA )
                , ( bp::arg("key"), bp::arg("size") )
                    /* undefined call policies */ );
        
        }
        { //::KeyValues::getIntA
        
            typedef int * ( ::KeyValues::*getIntA_function_type )( int,int & ) ;
            
            KeyValues_exposer.def( 
                "getIntA"
                , getIntA_function_type( &::KeyValues::getIntA )
                , ( bp::arg("pos"), bp::arg("size") )
                    /* undefined call policies */ );
        
        }
        { //::KeyValues::getIntV
        
            typedef ::std::vector< int > ( ::KeyValues::*getIntV_function_type )( int ) ;
            
            KeyValues_exposer.def( 
                "getIntV"
                , getIntV_function_type( &::KeyValues::getIntV )
                , ( bp::arg("pos") ) );
        
        }
        { //::KeyValues::getIntV
        
            typedef ::std::vector< int > ( ::KeyValues::*getIntV_function_type )( ::String ) ;
            
            KeyValues_exposer.def( 
                "getIntV"
                , getIntV_function_type( &::KeyValues::getIntV )
                , ( bp::arg("key") ) );
        
        }
        { //::KeyValues::getKeys
        
            typedef ::std::map< std::string, std::string > ( ::KeyValues::*getKeys_function_type )(  ) ;
            
            KeyValues_exposer.def( 
                "getKeys"
                , getKeys_function_type( &::KeyValues::getKeys ) );
        
        }
        { //::KeyValues::getName
        
            typedef ::String ( ::KeyValues::*getName_function_type )( ::String ) ;
            
            KeyValues_exposer.def( 
                "getName"
                , getName_function_type( &::KeyValues::getName )
                , ( bp::arg("key") ) );
        
        }
        { //::KeyValues::getOid
        
            typedef int ( ::KeyValues::*getOid_function_type )( ::String ) ;
            
            KeyValues_exposer.def( 
                "getOid"
                , getOid_function_type( &::KeyValues::getOid )
                , ( bp::arg("key") ) );
        
        }
        { //::KeyValues::getString
        
            typedef ::String ( ::KeyValues::*getString_function_type )( ::String ) ;
            
            KeyValues_exposer.def( 
                "getString"
                , getString_function_type( &::KeyValues::getString )
                , ( bp::arg("key") ) );
        
        }
        { //::KeyValues::getString
        
            typedef ::String ( ::KeyValues::*getString_function_type )( int ) ;
            
            KeyValues_exposer.def( 
                "getString"
                , getString_function_type( &::KeyValues::getString )
                , ( bp::arg("pos") ) );
        
        }
        { //::KeyValues::next
        
            typedef ::KeyValues * ( ::KeyValues::*next_function_type )(  ) ;
            
            KeyValues_exposer.def( 
                "next"
                , next_function_type( &::KeyValues::next )
                    /* undefined call policies */ );
        
        }
        { //::KeyValues::print
        
            typedef void ( ::KeyValues::*print_function_type )(  ) ;
            
            KeyValues_exposer.def( 
                "print"
                , print_function_type( &::KeyValues::print ) );
        
        }
        { //::KeyValues::printAll
        
            typedef void ( ::KeyValues::*printAll_function_type )(  ) ;
            
            KeyValues_exposer.def( 
                "printAll"
                , printAll_function_type( &::KeyValues::printAll ) );
        
        }
        { //::KeyValues::setFloat
        
            typedef bool ( ::KeyValues::*setFloat_function_type )( ::String,::String ) ;
            
            KeyValues_exposer.def( 
                "setFloat"
                , setFloat_function_type( &::KeyValues::setFloat )
                , ( bp::arg("key"), bp::arg("value") ) );
        
        }
        { //::KeyValues::setFloat
        
            typedef bool ( ::KeyValues::*setFloat_function_type )( ::String,float ) ;
            
            KeyValues_exposer.def( 
                "setFloat"
                , setFloat_function_type( &::KeyValues::setFloat )
                , ( bp::arg("key"), bp::arg("value") ) );
        
        }
        { //::KeyValues::setFloatA
        
            typedef bool ( ::KeyValues::*setFloatA_function_type )( ::String,float *,int ) ;
            
            KeyValues_exposer.def( 
                "setFloatA"
                , setFloatA_function_type( &::KeyValues::setFloatA )
                , ( bp::arg("key"), bp::arg("value"), bp::arg("size") ) );
        
        }
        { //::KeyValues::setInt
        
            typedef bool ( ::KeyValues::*setInt_function_type )( ::String,::String ) ;
            
            KeyValues_exposer.def( 
                "setInt"
                , setInt_function_type( &::KeyValues::setInt )
                , ( bp::arg("key"), bp::arg("value") ) );
        
        }
        { //::KeyValues::setInt
        
            typedef bool ( ::KeyValues::*setInt_function_type )( ::String,int ) ;
            
            KeyValues_exposer.def( 
                "setInt"
                , setInt_function_type( &::KeyValues::setInt )
                , ( bp::arg("key"), bp::arg("value") ) );
        
        }
        { //::KeyValues::setIntA
        
            typedef bool ( ::KeyValues::*setIntA_function_type )( ::String,int *,int ) ;
            
            KeyValues_exposer.def( 
                "setIntA"
                , setIntA_function_type( &::KeyValues::setIntA )
                , ( bp::arg("key"), bp::arg("value"), bp::arg("size") ) );
        
        }
        { //::KeyValues::setString
        
            typedef bool ( ::KeyValues::*setString_function_type )( ::String,::String ) ;
            
            KeyValues_exposer.def( 
                "setString"
                , setString_function_type( &::KeyValues::setString )
                , ( bp::arg("key"), bp::arg("value") ) );
        
        }
        KeyValues_exposer.add_property( "insert"
                    , bp::make_function( (::Insert * (*)( ::KeyValues const & ))(&KeyValues_wrapper::get_insert), bp::return_internal_reference< >() )
                    , bp::make_function( (void (*)( ::KeyValues &,::Insert * ))(&KeyValues_wrapper::set_insert), bp::with_custodian_and_ward_postcall< 1, 2 >() ) );
        KeyValues_exposer.def_readwrite( "pos", &KeyValues::pos );
        KeyValues_exposer.add_property( "select"
                    , bp::make_function( (::Select * (*)( ::KeyValues const & ))(&KeyValues_wrapper::get_select), bp::return_internal_reference< >() )
                    , bp::make_function( (void (*)( ::KeyValues &,::Select * ))(&KeyValues_wrapper::set_select), bp::with_custodian_and_ward_postcall< 1, 2 >() ) );
        { //::Commons::registerTypes
        
            typedef void ( KeyValues_wrapper::*registerTypes_function_type )(  ) ;
            
            KeyValues_exposer.def( 
                "registerTypes"
                , registerTypes_function_type( &KeyValues_wrapper::registerTypes ) );
        
        }
    }

    bp::class_< Dataset_wrapper, bp::bases< KeyValues > >( "Dataset", bp::init< KeyValues const &, bp::optional< String const & > >(( bp::arg("orig"), bp::arg("name")="" )) )    
        .def( 
            "getLocation"
            , (::String ( ::Dataset::* )(  ) )( &::Dataset::getLocation ) )    
        .def( 
            "getName"
            , (::String ( ::Dataset::* )(  ) )( &::Dataset::getName ) )    
        .def( 
            "newMethod"
            , (::Method * ( ::Dataset::* )( ::String const & ) )( &::Dataset::newMethod )
            , ( bp::arg("name")="" )
                /* undefined call policies */ )    
        .def( 
            "newProcess"
            , (::Process * ( ::Dataset::* )( ::String const & ) )( &::Dataset::newProcess )
            , ( bp::arg("name")="" )
                /* undefined call policies */ )    
        .def( 
            "newSequence"
            , (::Sequence * ( ::Dataset::* )( ::String const & ) )( &::Dataset::newSequence )
            , ( bp::arg("name")="" )
                /* undefined call policies */ )    
        .def( 
            "next"
            , (bool ( ::Dataset::* )(  ) )( &::Dataset::next ) )    
        .def( 
            "registerTypes"
            , (void ( Dataset_wrapper::* )(  ) )(&Dataset_wrapper::registerTypes) );

    bp::class_< Interval_wrapper, bp::bases< KeyValues > >( "Interval", bp::init< KeyValues const &, bp::optional< String const & > >(( bp::arg("orig"), bp::arg("selection")="intervals" )) )    
        .def( 
            "add"
            , (bool ( ::Interval::* )( ::String const &,int const,int const,::String const & ) )( &::Interval::add )
            , ( bp::arg("sequence"), bp::arg("t1"), bp::arg("t2")=(int const)(-0x00000000000000001), bp::arg("location")="" ) )    
        .def( 
            "getDataLocation"
            , (::String ( ::Interval::* )(  ) )( &::Interval::getDataLocation ) )    
        .def( 
            "getEndTime"
            , (int ( ::Interval::* )(  ) )( &::Interval::getEndTime ) )    
        .def( 
            "getLocation"
            , (::String ( ::Interval::* )(  ) )( &::Interval::getLocation ) )    
        .def( 
            "getSequence"
            , (::String ( ::Interval::* )(  ) )( &::Interval::getSequence ) )    
        .def( 
            "getStartTime"
            , (int ( ::Interval::* )(  ) )( &::Interval::getStartTime ) )    
        .def( 
            "registerTypes"
            , (void ( Interval_wrapper::* )(  ) )(&Interval_wrapper::registerTypes) );

    bp::class_< Image_wrapper, bp::bases< Interval > >( "Image", bp::init< KeyValues const &, bp::optional< String const & > >(( bp::arg("orig"), bp::arg("selection")="intervals" )) )    
        .def( 
            "add"
            , (bool ( ::Image::* )( ::String const &,int const,::String const & ) )( &::Image::add )
            , ( bp::arg("sequence"), bp::arg("t"), bp::arg("location") ) )    
        .def( 
            "getTime"
            , (int ( ::Image::* )(  ) )( &::Image::getTime ) )    
        .def( 
            "registerTypes"
            , (void ( Image_wrapper::* )(  ) )(&Image_wrapper::registerTypes) );

    bp::class_< Query_wrapper, bp::bases< Commons > >( "Query", bp::init< Commons const &, bp::optional< String const &, PGparam * > >(( bp::arg("commons"), bp::arg("query")="", bp::arg("param")=0l )) )    
        .def( 
            "execute"
            , (bool ( ::Query::* )(  ) )( &::Query::execute ) )    
        .def( 
            "getQuery"
            , (::String ( ::Query::* )(  ) )(&::Query::getQuery)
            , (::String ( Query_wrapper::* )(  ) )(&Query_wrapper::default_getQuery) )    
        .def( 
            "keyFloat"
            , (bool ( ::Query::* )( ::String const &,float const &,::String const & ) )( &::Query::keyFloat )
            , ( bp::arg("key"), bp::arg("value"), bp::arg("from")="" ) )    
        .def( 
            "keyFloatA"
            , (bool ( ::Query::* )( ::String const &,float const *,int const,::String const & ) )( &::Query::keyFloatA )
            , ( bp::arg("key"), bp::arg("values"), bp::arg("size"), bp::arg("from")="" ) )    
        .def( 
            "keyInt"
            , (bool ( ::Query::* )( ::String const &,int const &,::String const & ) )( &::Query::keyInt )
            , ( bp::arg("key"), bp::arg("value"), bp::arg("from")="" ) )    
        .def( 
            "keyIntA"
            , (bool ( ::Query::* )( ::String const &,int const *,int const,::String const & ) )( &::Query::keyIntA )
            , ( bp::arg("key"), bp::arg("values"), bp::arg("size"), bp::arg("from")="" ) )    
        .def( 
            "keyString"
            , (bool ( ::Query::* )( ::String const &,::String const &,::String const & ) )( &::Query::keyString )
            , ( bp::arg("key"), bp::arg("value"), bp::arg("from")="" ) )    
        .def( 
            "keyStringA"
            , (bool ( ::Query::* )( ::String const &,::String const *,int const,::String const & ) )( &::Query::keyStringA )
            , ( bp::arg("key"), bp::arg("values"), bp::arg("size"), bp::arg("from")="" ) )    
        .def( 
            "keyValue"
            , (bool ( ::Query::* )( ::TKey const & ) )( &::Query::keyValue )
            , ( bp::arg("key") ) )    
        .def_readwrite( "executed", &Query::executed )    
        .def_readwrite( "keys", &Query::keys )    
        .add_property( "param"
                    , bp::make_function( (::PGparam * (*)( ::Query const & ))(&Query_wrapper::get_param), bp::return_internal_reference< >() )
                    , bp::make_function( (void (*)( ::Query &,::PGparam * ))(&Query_wrapper::set_param), bp::with_custodian_and_ward_postcall< 1, 2 >() ) )    
        .def_readwrite( "queryString", &Query::queryString )    
        .add_property( "res"
                    , bp::make_function( (::PGresult * (*)( ::Query const & ))(&Query_wrapper::get_res), bp::return_internal_reference< >() )
                    , bp::make_function( (void (*)( ::Query &,::PGresult * ))(&Query_wrapper::set_res), bp::with_custodian_and_ward_postcall< 1, 2 >() ) )    
        .def( 
            "registerTypes"
            , (void ( Query_wrapper::* )(  ) )(&Query_wrapper::registerTypes) );

    bp::class_< Insert_wrapper, bp::bases< Query > >( "Insert", bp::init< Commons const &, bp::optional< String const &, PGparam * > >(( bp::arg("commons"), bp::arg("insertString")="", bp::arg("param")=0l )) )    
        .def( 
            "getQuery"
            , (::String ( ::Insert::* )(  ) )(&::Insert::getQuery)
            , (::String ( Insert_wrapper::* )(  ) )(&Insert_wrapper::default_getQuery) )    
        .def( 
            "into"
            , (bool ( ::Insert::* )( ::String const & ) )( &::Insert::into )
            , ( bp::arg("table") ) )    
        .def_readwrite( "intoTable", &Insert::intoTable )    
        .def( 
            "registerTypes"
            , (void ( Insert_wrapper::* )(  ) )(&Insert_wrapper::registerTypes) );

    bp::class_< Method_wrapper, bp::bases< KeyValues > >( "Method", bp::init< KeyValues const &, bp::optional< String const & > >(( bp::arg("orig"), bp::arg("name")="" )) )    
        .def( 
            "getMethodKeys"
            , (::std::vector< TKey > ( ::Method::* )(  ) )( &::Method::getMethodKeys ) )    
        .def( 
            "getName"
            , (::String ( ::Method::* )(  ) )( &::Method::getName ) )    
        .def( 
            "newProcess"
            , (::Process * ( ::Method::* )( ::String const & ) )( &::Method::newProcess )
            , ( bp::arg("name")="" )
                /* undefined call policies */ )    
        .def( 
            "next"
            , (bool ( ::Method::* )(  ) )( &::Method::next ) )    
        .def_readwrite( "methodKeys", &Method::methodKeys )    
        .def( 
            "registerTypes"
            , (void ( Method_wrapper::* )(  ) )(&Method_wrapper::registerTypes) );

    { //::PGarray
        typedef bp::class_< PGarray_wrapper > PGarray_exposer_t;
        PGarray_exposer_t PGarray_exposer = PGarray_exposer_t( "PGarray" );
        bp::scope PGarray_scope( PGarray_exposer );
        pyplusplus::containers::static_sized::register_array_1< int, 6 >( "__array_1_int_6" );
        { //PGarray::dims [variable], type=int[6]
        
            typedef pyplusplus::containers::static_sized::array_1_t< int, 6> ( *array_wrapper_creator )( ::PGarray & );
            
            PGarray_exposer.add_property( "dims"
                , bp::make_function( array_wrapper_creator(&PGarray_wrapper::pyplusplus_dims_wrapper)
                                    , bp::with_custodian_and_ward_postcall< 0, 1 >() ) );
        }
        { //PGarray::lbound [variable], type=int[6]
        
            typedef pyplusplus::containers::static_sized::array_1_t< int, 6> ( *array_wrapper_creator )( ::PGarray & );
            
            PGarray_exposer.add_property( "lbound"
                , bp::make_function( array_wrapper_creator(&PGarray_wrapper::pyplusplus_lbound_wrapper)
                                    , bp::with_custodian_and_ward_postcall< 0, 1 >() ) );
        }
        PGarray_exposer.def_readwrite( "ndims", &PGarray::ndims );
        PGarray_exposer.add_property( "param"
                    , bp::make_function( (::PGparam * (*)( ::PGarray const & ))(&PGarray_wrapper::get_param), bp::return_internal_reference< >() )
                    , bp::make_function( (void (*)( ::PGarray &,::PGparam * ))(&PGarray_wrapper::set_param), bp::with_custodian_and_ward_postcall< 1, 2 >() ) );
        PGarray_exposer.add_property( "res"
                    , bp::make_function( (::PGresult * (*)( ::PGarray const & ))(&PGarray_wrapper::get_res), bp::return_internal_reference< >() )
                    , bp::make_function( (void (*)( ::PGarray &,::PGresult * ))(&PGarray_wrapper::set_res), bp::with_custodian_and_ward_postcall< 1, 2 >() ) );
    }

    bp::class_< PGbox >( "PGbox" )    
        .def_readwrite( "high", &PGbox::high )    
        .def_readwrite( "low", &PGbox::low );

    bp::class_< PGbytea >( "PGbytea" )    
        .def_readwrite( "len", &PGbytea::len );

    bp::class_< PGcircle >( "PGcircle" )    
        .def_readwrite( "center", &PGcircle::center )    
        .def_readwrite( "radius", &PGcircle::radius );

    bp::class_< PGdate >( "PGdate" )    
        .def_readwrite( "isbc", &PGdate::isbc )    
        .def_readwrite( "jday", &PGdate::jday )    
        .def_readwrite( "mday", &PGdate::mday )    
        .def_readwrite( "mon", &PGdate::mon )    
        .def_readwrite( "wday", &PGdate::wday )    
        .def_readwrite( "yday", &PGdate::yday )    
        .def_readwrite( "year", &PGdate::year );

    { //::PGinet
        typedef bp::class_< PGinet_wrapper > PGinet_exposer_t;
        PGinet_exposer_t PGinet_exposer = PGinet_exposer_t( "PGinet" );
        bp::scope PGinet_scope( PGinet_exposer );
        PGinet_exposer.def_readwrite( "is_cidr", &PGinet::is_cidr );
        PGinet_exposer.def_readwrite( "mask", &PGinet::mask );
        pyplusplus::containers::static_sized::register_array_1< char, 128 >( "__array_1_char_128" );
        { //PGinet::sa_buf [variable], type=char[128]
        
            typedef pyplusplus::containers::static_sized::array_1_t< char, 128> ( *array_wrapper_creator )( ::PGinet & );
            
            PGinet_exposer.add_property( "sa_buf"
                , bp::make_function( array_wrapper_creator(&PGinet_wrapper::pyplusplus_sa_buf_wrapper)
                                    , bp::with_custodian_and_ward_postcall< 0, 1 >() ) );
        }
        PGinet_exposer.def_readwrite( "sa_buf_len", &PGinet::sa_buf_len );
    }

    bp::class_< PGinterval >( "PGinterval" )    
        .def_readwrite( "days", &PGinterval::days )    
        .def_readwrite( "hours", &PGinterval::hours )    
        .def_readwrite( "mins", &PGinterval::mins )    
        .def_readwrite( "mons", &PGinterval::mons )    
        .def_readwrite( "secs", &PGinterval::secs )    
        .def_readwrite( "usecs", &PGinterval::usecs )    
        .def_readwrite( "years", &PGinterval::years );

    { //::PGlseg
        typedef bp::class_< PGlseg_wrapper > PGlseg_exposer_t;
        PGlseg_exposer_t PGlseg_exposer = PGlseg_exposer_t( "PGlseg" );
        bp::scope PGlseg_scope( PGlseg_exposer );
        pyplusplus::containers::static_sized::register_array_1< ::PGpoint, 2, bp::return_internal_reference< > >( "__array_1__scope_PGpoint_2" );
        { //PGlseg::pts [variable], type=PGpoint[2]
        
            typedef pyplusplus::containers::static_sized::array_1_t< ::PGpoint, 2> ( *array_wrapper_creator )( ::PGlseg & );
            
            PGlseg_exposer.add_property( "pts"
                , bp::make_function( array_wrapper_creator(&PGlseg_wrapper::pyplusplus_pts_wrapper)
                                    , bp::with_custodian_and_ward_postcall< 0, 1 >() ) );
        }
    }

    bp::class_< PGmacaddr >( "PGmacaddr" )    
        .def_readwrite( "a", &PGmacaddr::a )    
        .def_readwrite( "b", &PGmacaddr::b )    
        .def_readwrite( "c", &PGmacaddr::c )    
        .def_readwrite( "d", &PGmacaddr::d )    
        .def_readwrite( "e", &PGmacaddr::e )    
        .def_readwrite( "f", &PGmacaddr::f );

    bp::class_< PGpath_wrapper >( "PGpath" )    
        .def_readwrite( "closed", &PGpath::closed )    
        .def_readwrite( "npts", &PGpath::npts )    
        .add_property( "pts"
                    , bp::make_function( (::PGpoint * (*)( ::PGpath const & ))(&PGpath_wrapper::get_pts), bp::return_internal_reference< >() )
                    , bp::make_function( (void (*)( ::PGpath &,::PGpoint * ))(&PGpath_wrapper::set_pts), bp::with_custodian_and_ward_postcall< 1, 2 >() ) );

    bp::class_< PGpoint >( "PGpoint" )    
        .def_readwrite( "x", &PGpoint::x )    
        .def_readwrite( "y", &PGpoint::y );

    bp::class_< PGpolygon_wrapper >( "PGpolygon" )    
        .def_readwrite( "npts", &PGpolygon::npts )    
        .add_property( "pts"
                    , bp::make_function( (::PGpoint * (*)( ::PGpolygon const & ))(&PGpolygon_wrapper::get_pts), bp::return_internal_reference< >() )
                    , bp::make_function( (void (*)( ::PGpolygon &,::PGpoint * ))(&PGpolygon_wrapper::set_pts), bp::with_custodian_and_ward_postcall< 1, 2 >() ) );

    { //::PGrecordAttDesc
        typedef bp::class_< PGrecordAttDesc_wrapper > PGrecordAttDesc_exposer_t;
        PGrecordAttDesc_exposer_t PGrecordAttDesc_exposer = PGrecordAttDesc_exposer_t( "PGrecordAttDesc" );
        bp::scope PGrecordAttDesc_scope( PGrecordAttDesc_exposer );
        PGrecordAttDesc_exposer.def_readwrite( "attlen", &PGrecordAttDesc::attlen );
        pyplusplus::containers::static_sized::register_array_1< char, 65 >( "__array_1_char_65" );
        { //PGrecordAttDesc::attname [variable], type=char[65]
        
            typedef pyplusplus::containers::static_sized::array_1_t< char, 65> ( *array_wrapper_creator )( ::PGrecordAttDesc & );
            
            PGrecordAttDesc_exposer.add_property( "attname"
                , bp::make_function( array_wrapper_creator(&PGrecordAttDesc_wrapper::pyplusplus_attname_wrapper)
                                    , bp::with_custodian_and_ward_postcall< 0, 1 >() ) );
        }
        PGrecordAttDesc_exposer.def_readwrite( "attoid", &PGrecordAttDesc::attoid );
        PGrecordAttDesc_exposer.def_readwrite( "atttypmod", &PGrecordAttDesc::atttypmod );
    }

    bp::class_< PGregisterType >( "PGregisterType" );

    { //::PGtime
        typedef bp::class_< PGtime_wrapper > PGtime_exposer_t;
        PGtime_exposer_t PGtime_exposer = PGtime_exposer_t( "PGtime" );
        bp::scope PGtime_scope( PGtime_exposer );
        PGtime_exposer.def_readwrite( "gmtoff", &PGtime::gmtoff );
        PGtime_exposer.def_readwrite( "hour", &PGtime::hour );
        PGtime_exposer.def_readwrite( "isdst", &PGtime::isdst );
        PGtime_exposer.def_readwrite( "min", &PGtime::min );
        PGtime_exposer.def_readwrite( "sec", &PGtime::sec );
        pyplusplus::containers::static_sized::register_array_1< char, 16 >( "__array_1_char_16" );
        { //PGtime::tzabbr [variable], type=char[16]
        
            typedef pyplusplus::containers::static_sized::array_1_t< char, 16> ( *array_wrapper_creator )( ::PGtime & );
            
            PGtime_exposer.add_property( "tzabbr"
                , bp::make_function( array_wrapper_creator(&PGtime_wrapper::pyplusplus_tzabbr_wrapper)
                                    , bp::with_custodian_and_ward_postcall< 0, 1 >() ) );
        }
        PGtime_exposer.def_readwrite( "usec", &PGtime::usec );
        PGtime_exposer.def_readwrite( "withtz", &PGtime::withtz );
    }

    bp::class_< PGtimestamp >( "PGtimestamp" )    
        .def_readwrite( "date", &PGtimestamp::date )    
        .def_readwrite( "epoch", &PGtimestamp::epoch )    
        .def_readwrite( "time", &PGtimestamp::time );

    { //::PGtypeFormatInfo
        typedef bp::class_< PGtypeFormatInfo_wrapper > PGtypeFormatInfo_exposer_t;
        PGtypeFormatInfo_exposer_t PGtypeFormatInfo_exposer = PGtypeFormatInfo_exposer_t( "PGtypeFormatInfo" );
        bp::scope PGtypeFormatInfo_scope( PGtypeFormatInfo_exposer );
        pyplusplus::containers::static_sized::register_array_1< char, 48 >( "__array_1_char_48" );
        { //PGtypeFormatInfo::datestyle [variable], type=char[48]
        
            typedef pyplusplus::containers::static_sized::array_1_t< char, 48> ( *array_wrapper_creator )( ::PGtypeFormatInfo & );
            
            PGtypeFormatInfo_exposer.add_property( "datestyle"
                , bp::make_function( array_wrapper_creator(&PGtypeFormatInfo_wrapper::pyplusplus_datestyle_wrapper)
                                    , bp::with_custodian_and_ward_postcall< 0, 1 >() ) );
        }
        PGtypeFormatInfo_exposer.def_readwrite( "integer_datetimes", &PGtypeFormatInfo::integer_datetimes );
        PGtypeFormatInfo_exposer.def_readwrite( "pversion", &PGtypeFormatInfo::pversion );
        PGtypeFormatInfo_exposer.def_readwrite( "sversion", &PGtypeFormatInfo::sversion );
    }

    bp::class_< Process_wrapper, bp::bases< KeyValues > >( "Process", bp::init< KeyValues const &, bp::optional< String const & > >(( bp::arg("orig"), bp::arg("name")="" )) )    
        .def( 
            "getInputs"
            , (::String ( ::Process::* )(  ) )( &::Process::getInputs ) )    
        .def( 
            "getName"
            , (::String ( ::Process::* )(  ) )( &::Process::getName ) )    
        .def( 
            "getOutputs"
            , (::String ( ::Process::* )(  ) )( &::Process::getOutputs ) )    
        .def( 
            "newInterval"
            , (::Interval * ( ::Process::* )( int const,int const ) )( &::Process::newInterval )
            , ( bp::arg("t1")=(int const)(-0x00000000000000001), bp::arg("t2")=(int const)(-0x00000000000000001) )
                /* undefined call policies */ )    
        .def( 
            "newSequence"
            , (::Sequence * ( ::Process::* )( ::String const & ) )( &::Process::newSequence )
            , ( bp::arg("name")="" )
                /* undefined call policies */ )    
        .def( 
            "next"
            , (bool ( ::Process::* )(  ) )( &::Process::next ) )    
        .def( 
            "registerTypes"
            , (void ( Process_wrapper::* )(  ) )(&Process_wrapper::registerTypes) );

    bp::class_< Select_wrapper, bp::bases< Query > >( "Select", bp::init< Commons const &, bp::optional< String const &, PGparam * > >(( bp::arg("commons"), bp::arg("queryString")="", bp::arg("param")=0l )) )    
        .def( 
            "from"
            , (bool ( ::Select::* )( ::String const &,::String const & ) )( &::Select::from )
            , ( bp::arg("table"), bp::arg("column") ) )    
        .def( 
            "getQuery"
            , (::String ( ::Select::* )(  ) )(&::Select::getQuery)
            , (::String ( Select_wrapper::* )(  ) )(&Select_wrapper::default_getQuery) )    
        .def( 
            "whereString"
            , (bool ( ::Select::* )( ::String const &,::String const &,::String const & ) )( &::Select::whereString )
            , ( bp::arg("key"), bp::arg("value"), bp::arg("table")="" ) )    
        .def_readwrite( "fromList", &Select::fromList )    
        .def_readwrite( "groupby", &Select::groupby )    
        .def_readwrite( "limit", &Select::limit )    
        .def_readwrite( "offset", &Select::offset )    
        .def_readwrite( "orderby", &Select::orderby )    
        .def_readwrite( "where", &Select::where )    
        .def( 
            "registerTypes"
            , (void ( Select_wrapper::* )(  ) )(&Select_wrapper::registerTypes) );

    bp::class_< Sequence_wrapper, bp::bases< KeyValues > >( "Sequence", bp::init< KeyValues const &, bp::optional< String const & > >(( bp::arg("orig"), bp::arg("name")="" )) )    
        .def( 
            "add"
            , (bool ( ::Sequence::* )( ::String,::String ) )( &::Sequence::add )
            , ( bp::arg("name"), bp::arg("location") ) )    
        .def( 
            "getLocation"
            , (::String ( ::Sequence::* )(  ) )( &::Sequence::getLocation ) )    
        .def( 
            "getName"
            , (::String ( ::Sequence::* )(  ) )( &::Sequence::getName ) )    
        .def( 
            "newInterval"
            , (::Interval * ( ::Sequence::* )( int const,int const ) )( &::Sequence::newInterval )
            , ( bp::arg("t1")=(int const)(-0x00000000000000001), bp::arg("t2")=(int const)(-0x00000000000000001) )
                /* undefined call policies */ )    
        .def( 
            "newProcess"
            , (::Process * ( ::Sequence::* )( ::String const & ) )( &::Sequence::newProcess )
            , ( bp::arg("name")="" )
                /* undefined call policies */ )    
        .def( 
            "next"
            , (bool ( ::Sequence::* )(  ) )( &::Sequence::next ) )    
        .def( 
            "openImage"
            , (bool ( Sequence_wrapper::* )( ::String const & ) )(&Sequence_wrapper::openImage)
            , ( bp::arg("name") ) )    
        .def( 
            "openVideo"
            , (bool ( Sequence_wrapper::* )( ::String const & ) )(&Sequence_wrapper::openVideo)
            , ( bp::arg("name") ) )    
        .def( 
            "registerTypes"
            , (void ( Sequence_wrapper::* )(  ) )(&Sequence_wrapper::registerTypes) );

    bp::class_< TKey >( "TKey", bp::init< >() )    
        .def( bp::init< String const &, String const &, int, bp::optional< String const & > >(( bp::arg("type"), bp::arg("key"), bp::arg("size"), bp::arg("from")="" )) )    
        .def( 
            "print"
            , (::String ( ::TKey::* )(  ) )( &::TKey::print ) )    
        .def_readwrite( "from", &TKey::from )    
        .def_readwrite( "key", &TKey::key )    
        .def_readwrite( "size", &TKey::size )    
        .def_readwrite( "type", &TKey::type );

    bp::class_< TypeMap >( "TypeMap", bp::init< >() )    
        .def( 
            "clear"
            , (void ( ::TypeMap::* )(  ) )( &::TypeMap::clear ) )    
        .def( 
            "empty"
            , (bool ( ::TypeMap::* )(  ) )( &::TypeMap::empty ) )    
        .def( 
            "insert"
            , (void ( ::TypeMap::* )( int,::String ) )( &::TypeMap::insert )
            , ( bp::arg("oid"), bp::arg("typname") ) )    
        .def( 
            "insert"
            , (void ( ::TypeMap::* )( ::String,int ) )( &::TypeMap::insert )
            , ( bp::arg("typname"), bp::arg("oid") ) )    
        .def( 
            "size"
            , (int ( ::TypeMap::* )(  ) )( &::TypeMap::size ) )    
        .def( 
            "toOid"
            , (int ( ::TypeMap::* )( ::String ) )( &::TypeMap::toOid )
            , ( bp::arg("typname") ) )    
        .def( 
            "toTypname"
            , (::String ( ::TypeMap::* )( int ) )( &::TypeMap::toTypname )
            , ( bp::arg("Oid") ) )    
        .def_readwrite( "dataloaded", &TypeMap::dataloaded );

    { //::VTApi
        typedef bp::class_< VTApi_wrapper > VTApi_exposer_t;
        VTApi_exposer_t VTApi_exposer = VTApi_exposer_t( "VTApi", bp::init< int, char * * >(( bp::arg("argc"), bp::arg("argv") )) );
        bp::scope VTApi_scope( VTApi_exposer );
        VTApi_exposer.def( bp::init< String const & >(( bp::arg("configFile") )) );
        bp::implicitly_convertible< String const &, VTApi >();
        VTApi_exposer.def( bp::init< String const &, String const &, String const &, String const & >(( bp::arg("connStr"), bp::arg("location"), bp::arg("user"), bp::arg("password") )) );
        VTApi_exposer.def( bp::init< Commons const & >(( bp::arg("orig") )) );
        bp::implicitly_convertible< Commons const &, VTApi >();
        VTApi_exposer.def( bp::init< VTApi const & >(( bp::arg("orig") )) );
        { //::VTApi::newDataset
        
            typedef ::Dataset * ( ::VTApi::*newDataset_function_type )( ::String const & ) ;
            
            VTApi_exposer.def( 
                "newDataset"
                , newDataset_function_type( &::VTApi::newDataset )
                , ( bp::arg("name")="" )
                    /* undefined call policies */ );
        
        }
        { //::VTApi::newMethod
        
            typedef ::Method * ( ::VTApi::*newMethod_function_type )( ::String const & ) ;
            
            VTApi_exposer.def( 
                "newMethod"
                , newMethod_function_type( &::VTApi::newMethod )
                , ( bp::arg("name")="" )
                    /* undefined call policies */ );
        
        }
        { //::VTApi::newProcess
        
            typedef ::Process * ( ::VTApi::*newProcess_function_type )( ::String const & ) ;
            
            VTApi_exposer.def( 
                "newProcess"
                , newProcess_function_type( &::VTApi::newProcess )
                , ( bp::arg("name")="" )
                    /* undefined call policies */ );
        
        }
        { //::VTApi::test
        
            typedef void ( ::VTApi::*test_function_type )(  ) ;
            
            VTApi_exposer.def( 
                "test"
                , test_function_type( &::VTApi::test ) );
        
        }
        VTApi_exposer.add_property( "commons"
                    , bp::make_function( (::Commons * (*)( ::VTApi const & ))(&VTApi_wrapper::get_commons), bp::return_internal_reference< >() )
                    , bp::make_function( (void (*)( ::VTApi &,::Commons * ))(&VTApi_wrapper::set_commons), bp::with_custodian_and_ward_postcall< 1, 2 >() ) );
    }

    bp::class_< cmdline_parser_params >( "cmdline_parser_params" )    
        .def_readwrite( "check_ambiguity", &cmdline_parser_params::check_ambiguity )    
        .def_readwrite( "check_required", &cmdline_parser_params::check_required )    
        .def_readwrite( "initialize", &cmdline_parser_params::initialize )    
        .def_readwrite( "override", &cmdline_parser_params::override )    
        .def_readwrite( "print_errors", &cmdline_parser_params::print_errors );

    bp::class_< gengetopt_args_info_wrapper >( "gengetopt_args_info" )    
        .def_readwrite( "config_given", &gengetopt_args_info::config_given )    
        .def_readwrite( "connection_given", &gengetopt_args_info::connection_given )    
        .def_readwrite( "dataset_given", &gengetopt_args_info::dataset_given )    
        .def_readwrite( "format_given", &gengetopt_args_info::format_given )    
        .def_readwrite( "help_given", &gengetopt_args_info::help_given )    
        .add_property( "inputs"
                    , bp::make_function( (char * * (*)( ::gengetopt_args_info const & ))(&gengetopt_args_info_wrapper::get_inputs), bp::return_internal_reference< >() )
                    , bp::make_function( (void (*)( ::gengetopt_args_info &,char * * ))(&gengetopt_args_info_wrapper::set_inputs), bp::with_custodian_and_ward_postcall< 1, 2 >() ) )    
        .def_readwrite( "inputs_num", &gengetopt_args_info::inputs_num )    
        .def_readwrite( "interval_given", &gengetopt_args_info::interval_given )    
        .def_readwrite( "location_given", &gengetopt_args_info::location_given )    
        .def_readwrite( "method_given", &gengetopt_args_info::method_given )    
        .def_readwrite( "password_given", &gengetopt_args_info::password_given )    
        .def_readwrite( "process_given", &gengetopt_args_info::process_given )    
        .def_readwrite( "read_given", &gengetopt_args_info::read_given )    
        .def_readwrite( "selection_given", &gengetopt_args_info::selection_given )    
        .def_readwrite( "sequence_given", &gengetopt_args_info::sequence_given )    
        .def_readwrite( "user_given", &gengetopt_args_info::user_given )    
        .def_readwrite( "verbose_given", &gengetopt_args_info::verbose_given )    
        .def_readwrite( "version_given", &gengetopt_args_info::version_given )    
        .def_readwrite( "where_given", &gengetopt_args_info::where_given )    
        .def_readwrite( "write_given", &gengetopt_args_info::write_given );

    { //::pg_typeargs
        typedef bp::class_< pg_typeargs_wrapper > pg_typeargs_exposer_t;
        pg_typeargs_exposer_t pg_typeargs_exposer = pg_typeargs_exposer_t( "pg_typeargs" );
        bp::scope pg_typeargs_scope( pg_typeargs_exposer );
        pg_typeargs_exposer.def_readwrite( "field_num", &pg_typeargs::field_num );
        pg_typeargs_exposer.def_readwrite( "tup_num", &pg_typeargs::tup_num );
        pg_typeargs_exposer.def_readwrite( "outl", &pg_typeargs::outl );
        pyplusplus::containers::static_sized::register_array_1< ::__va_list_tag, 1, bp::return_internal_reference< > >( "__array_1__scope___va_list_tag_1" );
        { //pg_typeargs::ap [variable], type=va_list
        
            typedef pyplusplus::containers::static_sized::array_1_t< ::__va_list_tag, 1> ( *array_wrapper_creator )( ::pg_typeargs & );
            
            pg_typeargs_exposer.add_property( "ap"
                , bp::make_function( array_wrapper_creator(&pg_typeargs_wrapper::pyplusplus_ap_wrapper)
                                    , bp::with_custodian_and_ward_postcall< 0, 1 >() ) );
        }
        pg_typeargs_exposer.add_property( "fmtinfo"
                    , bp::make_function( (::PGtypeFormatInfo const * (*)( ::pg_typeargs const & ))(&pg_typeargs_wrapper::get_fmtinfo), bp::return_internal_reference< >() )
                    , bp::make_function( (void (*)( ::pg_typeargs &,::PGtypeFormatInfo const * ))(&pg_typeargs_wrapper::set_fmtinfo), bp::with_custodian_and_ward_postcall< 1, 2 >() ) );
        pg_typeargs_exposer.def_readwrite( "format", &pg_typeargs::format );
        pg_typeargs_exposer.def_readwrite( "is_ptr", &pg_typeargs::is_ptr );
        pg_typeargs_exposer.def_readwrite( "is_put", &pg_typeargs::is_put );
        pg_typeargs_exposer.add_property( "typhandler"
                    , bp::make_function( (::PGtypeHandler * (*)( ::pg_typeargs const & ))(&pg_typeargs_wrapper::get_typhandler), bp::return_internal_reference< >() )
                    , bp::make_function( (void (*)( ::pg_typeargs &,::PGtypeHandler * ))(&pg_typeargs_wrapper::set_typhandler), bp::with_custodian_and_ward_postcall< 1, 2 >() ) );
        pg_typeargs_exposer.def_readwrite( "typpos", &pg_typeargs::typpos );
    }

    { //::pg_typhandler
        typedef bp::class_< pg_typhandler_wrapper > pg_typhandler_exposer_t;
        pg_typhandler_exposer_t pg_typhandler_exposer = pg_typhandler_exposer_t( "pg_typhandler" );
        bp::scope pg_typhandler_scope( pg_typhandler_exposer );
        pg_typhandler_exposer.add_property( "attDescs"
                    , bp::make_function( (::PGrecordAttDesc * (*)( ::pg_typhandler const & ))(&pg_typhandler_wrapper::get_attDescs), bp::return_internal_reference< >() )
                    , bp::make_function( (void (*)( ::pg_typhandler &,::PGrecordAttDesc * ))(&pg_typhandler_wrapper::set_attDescs), bp::with_custodian_and_ward_postcall< 1, 2 >() ) );
        pyplusplus::containers::static_sized::register_array_1< ::PGrecordAttDesc, 16, bp::return_internal_reference< > >( "__array_1__scope_PGrecordAttDesc_16" );
        { //pg_typhandler::attDescsBuf [variable], type=PGrecordAttDesc[16]
        
            typedef pyplusplus::containers::static_sized::array_1_t< ::PGrecordAttDesc, 16> ( *array_wrapper_creator )( ::pg_typhandler & );
            
            pg_typhandler_exposer.add_property( "attDescsBuf"
                , bp::make_function( array_wrapper_creator(&pg_typhandler_wrapper::pyplusplus_attDescsBuf_wrapper)
                                    , bp::with_custodian_and_ward_postcall< 0, 1 >() ) );
        }
        pg_typhandler_exposer.def_readwrite( "base_id", &pg_typhandler::base_id );
        pg_typhandler_exposer.def_readwrite( "freeAttDescs", &pg_typhandler::freeAttDescs );
        pg_typhandler_exposer.def_readwrite( "id", &pg_typhandler::id );
        pg_typhandler_exposer.def_readwrite( "nattrs", &pg_typhandler::nattrs );
        pg_typhandler_exposer.def_readwrite( "typlen", &pg_typhandler::typlen );
        { //pg_typhandler::typname [variable], type=char[65]
        
            typedef pyplusplus::containers::static_sized::array_1_t< char, 65> ( *array_wrapper_creator )( ::pg_typhandler & );
            
            pg_typhandler_exposer.add_property( "typname"
                , bp::make_function( array_wrapper_creator(&pg_typhandler_wrapper::pyplusplus_typname_wrapper)
                                    , bp::with_custodian_and_ward_postcall< 0, 1 >() ) );
        }
        pg_typhandler_exposer.def_readwrite( "typoid", &pg_typhandler::typoid );
        pg_typhandler_exposer.def_readwrite( "typoid_array", &pg_typhandler::typoid_array );
        { //pg_typhandler::typschema [variable], type=char[65]
        
            typedef pyplusplus::containers::static_sized::array_1_t< char, 65> ( *array_wrapper_creator )( ::pg_typhandler & );
            
            pg_typhandler_exposer.add_property( "typschema"
                , bp::make_function( array_wrapper_creator(&pg_typhandler_wrapper::pyplusplus_typschema_wrapper)
                                    , bp::with_custodian_and_ward_postcall< 0, 1 >() ) );
        }
    }

    { //::PQclearSpecs
    
        typedef int ( *PQclearSpecs_function_type )( ::PGconn * );
        
        bp::def( 
            "PQclearSpecs"
            , PQclearSpecs_function_type( &::PQclearSpecs )
            , ( bp::arg("conn") ) );
    
    }

    { //::PQclearTypes
    
        typedef int ( *PQclearTypes_function_type )( ::PGconn * );
        
        bp::def( 
            "PQclearTypes"
            , PQclearTypes_function_type( &::PQclearTypes )
            , ( bp::arg("conn") ) );
    
    }

    { //::PQexecvf
    
        typedef ::PGresult * ( *PQexecvf_function_type )( ::PGconn *,char const *,::__va_list_tag * );
        
        bp::def( 
            "PQexecvf"
            , PQexecvf_function_type( &::PQexecvf )
            , ( bp::arg("conn"), bp::arg("cmdspec"), bp::arg("ap") )
                /* undefined call policies */ );
    
    }

    { //::PQgetErrorField
    
        typedef char * ( *PQgetErrorField_function_type )( int );
        
        bp::def( 
            "PQgetErrorField"
            , PQgetErrorField_function_type( &::PQgetErrorField )
            , ( bp::arg("fieldcode") )
                /* undefined call policies */ );
    
    }

    { //::PQgeterror
    
        typedef char * ( *PQgeterror_function_type )(  );
        
        bp::def( 
            "PQgeterror"
            , PQgeterror_function_type( &::PQgeterror )
                /* undefined call policies */ );
    
    }

    { //::PQgetvf
    
        typedef int ( *PQgetvf_function_type )( ::PGresult const *,int,char const *,::__va_list_tag * );
        
        bp::def( 
            "PQgetvf"
            , PQgetvf_function_type( &::PQgetvf )
            , ( bp::arg("res"), bp::arg("tup_num"), bp::arg("format"), bp::arg("ap") ) );
    
    }

    { //::PQinitTypes
    
        typedef int ( *PQinitTypes_function_type )( ::PGconn * );
        
        bp::def( 
            "PQinitTypes"
            , PQinitTypes_function_type( &::PQinitTypes )
            , ( bp::arg("conn") ) );
    
    }

    { //::PQlocalTZInfo
    
        typedef void ( *PQlocalTZInfo_function_type )( ::time_t *,int *,int *,char * * );
        
        bp::def( 
            "PQlocalTZInfo"
            , PQlocalTZInfo_function_type( &::PQlocalTZInfo )
            , ( bp::arg("t"), bp::arg("gmtoff"), bp::arg("isdst"), bp::arg("tzabbrp") ) );
    
    }

    { //::PQparamClear
    
        typedef void ( *PQparamClear_function_type )( ::PGparam * );
        
        bp::def( 
            "PQparamClear"
            , PQparamClear_function_type( &::PQparamClear )
            , ( bp::arg("param") ) );
    
    }

    { //::PQparamCount
    
        typedef int ( *PQparamCount_function_type )( ::PGparam * );
        
        bp::def( 
            "PQparamCount"
            , PQparamCount_function_type( &::PQparamCount )
            , ( bp::arg("param") ) );
    
    }

    { //::PQparamCreate
    
        typedef ::PGparam * ( *PQparamCreate_function_type )( ::PGconn const * );
        
        bp::def( 
            "PQparamCreate"
            , PQparamCreate_function_type( &::PQparamCreate )
            , ( bp::arg("conn") )
                /* undefined call policies */ );
    
    }

    { //::PQparamDup
    
        typedef ::PGparam * ( *PQparamDup_function_type )( ::PGparam * );
        
        bp::def( 
            "PQparamDup"
            , PQparamDup_function_type( &::PQparamDup )
            , ( bp::arg("param") )
                /* undefined call policies */ );
    
    }

    { //::PQparamExec
    
        typedef ::PGresult * ( *PQparamExec_function_type )( ::PGconn *,::PGparam *,char const *,int );
        
        bp::def( 
            "PQparamExec"
            , PQparamExec_function_type( &::PQparamExec )
            , ( bp::arg("conn"), bp::arg("param"), bp::arg("command"), bp::arg("resultFormat") )
                /* undefined call policies */ );
    
    }

    { //::PQparamExecPrepared
    
        typedef ::PGresult * ( *PQparamExecPrepared_function_type )( ::PGconn *,::PGparam *,char const *,int );
        
        bp::def( 
            "PQparamExecPrepared"
            , PQparamExecPrepared_function_type( &::PQparamExecPrepared )
            , ( bp::arg("conn"), bp::arg("param"), bp::arg("stmtName"), bp::arg("resultFormat") )
                /* undefined call policies */ );
    
    }

    { //::PQparamReset
    
        typedef void ( *PQparamReset_function_type )( ::PGparam * );
        
        bp::def( 
            "PQparamReset"
            , PQparamReset_function_type( &::PQparamReset )
            , ( bp::arg("param") ) );
    
    }

    { //::PQparamSendQuery
    
        typedef int ( *PQparamSendQuery_function_type )( ::PGconn *,::PGparam *,char const *,int );
        
        bp::def( 
            "PQparamSendQuery"
            , PQparamSendQuery_function_type( &::PQparamSendQuery )
            , ( bp::arg("conn"), bp::arg("param"), bp::arg("command"), bp::arg("resultFormat") ) );
    
    }

    { //::PQparamSendQueryPrepared
    
        typedef int ( *PQparamSendQueryPrepared_function_type )( ::PGconn *,::PGparam *,char const *,int );
        
        bp::def( 
            "PQparamSendQueryPrepared"
            , PQparamSendQueryPrepared_function_type( &::PQparamSendQueryPrepared )
            , ( bp::arg("conn"), bp::arg("param"), bp::arg("stmtName"), bp::arg("resultFormat") ) );
    
    }

    { //::PQputvf
    
        typedef int ( *PQputvf_function_type )( ::PGparam *,char *,::size_t,char const *,::__va_list_tag * );
        
        bp::def( 
            "PQputvf"
            , PQputvf_function_type( &::PQputvf )
            , ( bp::arg("param"), bp::arg("stmtBuf"), bp::arg("stmtBufLen"), bp::arg("format"), bp::arg("ap") ) );
    
    }

    { //::PQregisterComposites
    
        typedef int ( *PQregisterComposites_function_type )( ::PGconn *,::PGregisterType *,int );
        
        bp::def( 
            "PQregisterComposites"
            , PQregisterComposites_function_type( &::PQregisterComposites )
            , ( bp::arg("conn"), bp::arg("types"), bp::arg("count") ) );
    
    }

    { //::PQregisterResult
    
        typedef int ( *PQregisterResult_function_type )( ::PGconn *,int,::PGregisterType *,int,::PGresult * );
        
        bp::def( 
            "PQregisterResult"
            , PQregisterResult_function_type( &::PQregisterResult )
            , ( bp::arg("conn"), bp::arg("which"), bp::arg("types"), bp::arg("count"), bp::arg("res") ) );
    
    }

    { //::PQregisterSubClasses
    
        typedef int ( *PQregisterSubClasses_function_type )( ::PGconn *,::PGregisterType *,int );
        
        bp::def( 
            "PQregisterSubClasses"
            , PQregisterSubClasses_function_type( &::PQregisterSubClasses )
            , ( bp::arg("conn"), bp::arg("types"), bp::arg("count") ) );
    
    }

    { //::PQregisterTypes
    
        typedef int ( *PQregisterTypes_function_type )( ::PGconn *,int,::PGregisterType *,int,int );
        
        bp::def( 
            "PQregisterTypes"
            , PQregisterTypes_function_type( &::PQregisterTypes )
            , ( bp::arg("conn"), bp::arg("which"), bp::arg("types"), bp::arg("count"), bp::arg("async") ) );
    
    }

    { //::PQregisterUserDefinedTypes
    
        typedef int ( *PQregisterUserDefinedTypes_function_type )( ::PGconn *,::PGregisterType *,int );
        
        bp::def( 
            "PQregisterUserDefinedTypes"
            , PQregisterUserDefinedTypes_function_type( &::PQregisterUserDefinedTypes )
            , ( bp::arg("conn"), bp::arg("types"), bp::arg("count") ) );
    
    }

    { //::PQsendvf
    
        typedef int ( *PQsendvf_function_type )( ::PGconn *,char const *,::__va_list_tag * );
        
        bp::def( 
            "PQsendvf"
            , PQsendvf_function_type( &::PQsendvf )
            , ( bp::arg("conn"), bp::arg("cmdspec"), bp::arg("ap") ) );
    
    }

    { //::PQspecPrepare
    
        typedef int ( *PQspecPrepare_function_type )( ::PGconn *,char const *,char const *,int );
        
        bp::def( 
            "PQspecPrepare"
            , PQspecPrepare_function_type( &::PQspecPrepare )
            , ( bp::arg("conn"), bp::arg("name"), bp::arg("format"), bp::arg("is_stmt") ) );
    
    }

    { //::PQtypesRegister
    
        typedef int ( *PQtypesRegister_function_type )( ::PGconn * );
        
        bp::def( 
            "PQtypesRegister"
            , PQtypesRegister_function_type( &::PQtypesRegister )
            , ( bp::arg("conn") ) );
    
    }

    { //::cmdline_parser
    
        typedef int ( *cmdline_parser_function_type )( int,char * *,::gengetopt_args_info * );
        
        bp::def( 
            "cmdline_parser"
            , cmdline_parser_function_type( &::cmdline_parser )
            , ( bp::arg("argc"), bp::arg("argv"), bp::arg("args_info") ) );
    
    }

    { //::cmdline_parser2
    
        typedef int ( *cmdline_parser2_function_type )( int,char * *,::gengetopt_args_info *,int,int,int );
        
        bp::def( 
            "cmdline_parser2"
            , cmdline_parser2_function_type( &::cmdline_parser2 )
            , ( bp::arg("argc"), bp::arg("argv"), bp::arg("args_info"), bp::arg("override"), bp::arg("initialize"), bp::arg("check_required") ) );
    
    }

    { //::cmdline_parser_config_file
    
        typedef int ( *cmdline_parser_config_file_function_type )( char const *,::gengetopt_args_info *,::cmdline_parser_params * );
        
        bp::def( 
            "cmdline_parser_config_file"
            , cmdline_parser_config_file_function_type( &::cmdline_parser_config_file )
            , ( bp::arg("filename"), bp::arg("args_info"), bp::arg("params") ) );
    
    }

    { //::cmdline_parser_configfile
    
        typedef int ( *cmdline_parser_configfile_function_type )( char const *,::gengetopt_args_info *,int,int,int );
        
        bp::def( 
            "cmdline_parser_configfile"
            , cmdline_parser_configfile_function_type( &::cmdline_parser_configfile )
            , ( bp::arg("filename"), bp::arg("args_info"), bp::arg("override"), bp::arg("initialize"), bp::arg("check_required") ) );
    
    }

    { //::cmdline_parser_dump
    
        typedef int ( *cmdline_parser_dump_function_type )( ::FILE *,::gengetopt_args_info * );
        
        bp::def( 
            "cmdline_parser_dump"
            , cmdline_parser_dump_function_type( &::cmdline_parser_dump )
            , ( bp::arg("outfile"), bp::arg("args_info") ) );
    
    }

    { //::cmdline_parser_ext
    
        typedef int ( *cmdline_parser_ext_function_type )( int,char * *,::gengetopt_args_info *,::cmdline_parser_params * );
        
        bp::def( 
            "cmdline_parser_ext"
            , cmdline_parser_ext_function_type( &::cmdline_parser_ext )
            , ( bp::arg("argc"), bp::arg("argv"), bp::arg("args_info"), bp::arg("params") ) );
    
    }

    { //::cmdline_parser_file_save
    
        typedef int ( *cmdline_parser_file_save_function_type )( char const *,::gengetopt_args_info * );
        
        bp::def( 
            "cmdline_parser_file_save"
            , cmdline_parser_file_save_function_type( &::cmdline_parser_file_save )
            , ( bp::arg("filename"), bp::arg("args_info") ) );
    
    }

    { //::cmdline_parser_free
    
        typedef void ( *cmdline_parser_free_function_type )( ::gengetopt_args_info * );
        
        bp::def( 
            "cmdline_parser_free"
            , cmdline_parser_free_function_type( &::cmdline_parser_free )
            , ( bp::arg("args_info") ) );
    
    }

    { //::cmdline_parser_init
    
        typedef void ( *cmdline_parser_init_function_type )( ::gengetopt_args_info * );
        
        bp::def( 
            "cmdline_parser_init"
            , cmdline_parser_init_function_type( &::cmdline_parser_init )
            , ( bp::arg("args_info") ) );
    
    }

    { //::cmdline_parser_params_create
    
        typedef ::cmdline_parser_params * ( *cmdline_parser_params_create_function_type )(  );
        
        bp::def( 
            "cmdline_parser_params_create"
            , cmdline_parser_params_create_function_type( &::cmdline_parser_params_create )
                /* undefined call policies */ );
    
    }

    { //::cmdline_parser_params_init
    
        typedef void ( *cmdline_parser_params_init_function_type )( ::cmdline_parser_params * );
        
        bp::def( 
            "cmdline_parser_params_init"
            , cmdline_parser_params_init_function_type( &::cmdline_parser_params_init )
            , ( bp::arg("params") ) );
    
    }

    { //::cmdline_parser_print_help
    
        typedef void ( *cmdline_parser_print_help_function_type )(  );
        
        bp::def( 
            "cmdline_parser_print_help"
            , cmdline_parser_print_help_function_type( &::cmdline_parser_print_help ) );
    
    }

    { //::cmdline_parser_print_version
    
        typedef void ( *cmdline_parser_print_version_function_type )(  );
        
        bp::def( 
            "cmdline_parser_print_version"
            , cmdline_parser_print_version_function_type( &::cmdline_parser_print_version ) );
    
    }

    { //::cmdline_parser_required
    
        typedef int ( *cmdline_parser_required_function_type )( ::gengetopt_args_info *,char const * );
        
        bp::def( 
            "cmdline_parser_required"
            , cmdline_parser_required_function_type( &::cmdline_parser_required )
            , ( bp::arg("args_info"), bp::arg("prog_name") ) );
    
    }

    { //::toString
    
        typedef ::std::string ( *toString_function_type )( int const & );
        
        bp::def( 
            "toString"
            , toString_function_type( &::toString )
            , ( bp::arg("t") ) );
    
    }
}
